# Token

> 어떤 리소스를 얻기 위해서는 사용자 인증이라는 과정이 필요하다. 물론 모두에게 열려있는 리소스도 있지만, 대부분의 서비스는 그렇지 않다. 따라서 사용자 인증은 필수적인 과정이다.
>
> 사용자 인증방법에는 다음과같은 4가지 방법이 있다.
>
> 1. 지식 기반 인증 : ID/PW 와 같이 사용자가 알고있는 정보를 이용하여 인증한다.
> 2. 소지 기반 인증 : 토큰, 여권 등과 같은 사용자가 가지고 있는것을 통하여 인증한다.
> 3. 정적 생채 인증 : 홍채나 지문등을 이용하여 인증한다.
> 4. 동적 생채 인증 : 목소리, 행동패턴 등을 이용하여 인증한다.
>
> 이중 소지 기반 인증중 토큰에 대해 설명하려고 한다.
>
> 
>
> 토큰 기반 인증은 모던 웹서비스에서 많이 사용되는 인증방법이다. 이전에는 session인증을 많이 사용했는데 이 방법은 서버쪽에서 유저들의 정보는 기억하고 있는 방법입니다. 이 session을 유지하기위해 서버의 공간을 사용해야한다. 문제는 유저가 많아질 수록 서버의 무리가 된다.
>
> 토큰 기반 시스템은 stateless이다. 토큰을 발행하기 전 한번만 데이터베이스에서 유저의 유효성을 조회하고, 이후에는 토큰의 유효성만을 판단하고 요청에대한 응답만 해주면 된다.
>
> 정보를 서버에 저장하지 않고, 응답만 해주기 때문에 서버의 확장이나, 서버의 과부화문제에서부터 자유로울 수 있다.



## JWT

> JWT( Json Web Token ) 는 토큰 기반 인증 시스템의 구현체이다. JWT는 필요한 정보를 자체적으로 지니고 있다. 때문에 JWT를 이용하여 서비스를 구현할 때는, 토큰내에 담는 정보가 유출되어도 상관없는 정보여야 한다.



- JWT는 다음과 같은 상황에서 유용하게 사용된다.
  1. **회원인증**
  2. **정보 교류** : 두 개체 사이에서 안정성있게 정보를 교환하기 좋다. JWT는 특정 키로 해싱되어 있기 때문에 정보의 발신자와 조작여부를 검증할 수 있다.



- JWT 구조

  ```
  aaaaaaaaa.bbbbbbbbb.ccccccc
  --------- --------- ---------
   header    payload  signature
  ```

  **1. header**

  ```
  {
      "typ" : "JWT",
      "alg" : "HS256"
  }
  ```

  **2. payload**

  여기에 담는 key-value 쌍을 claim이라고 부른다.

  ```
  {
  	"key" : "value"   
  }
  ```

  **3.signature**

  서명은 헤더의 인코딩 값과, payload의 정보를 인코딩한 값을 합친뒤 서버가 가지고있는 비밀 키를 이용해 해쉬하여 생성한다.

  ```
  HMACSHA256(
    base64UrlEncode(header) + "." + base64UrlEncode(payload),
    '서버의 비밀 키')
  ```

  

- JWT는 토큰 자체에 정보가 있다는 부분이 큰 위험으로 작용될 수 있다. payload의 정보는 단순히 인코딩된 데이터로, 데이터를 누구나 볼 수 있다. 이러한 문제를 해결하기 위해 payload부분에 중요한 정보를 넣치 않거나 JWE( Json Web Encrytion )을 사용한다.



## JWT in ios

사용자 인증을 위해 JWT를 적용해 보았다. 토큰 방식 인증은 간편하게 사용할 수 있지만, 보안에 대한 부분이 계속 마음에 걸렸다. 토큰을 어디에 저장 해야 할지부터 토큰이 만료된다면 어떻게 재발급 할 것인가에 대한 부분등 여러가지 이슈가 있었다.

고민끝에 아래와 같은 플로우로 토큰을 사용하기로 했다.![tokenFlow](https://github.com/wallypark710/TIL/raw/master/Note/tokenFlow.png)

1. 유저가 최초 회원가입을 하면 서버는 유저에게 Refresh token 과 Access toekn을 발급해준다.

2. Refresh token은 안전한 저장소에 저장되고, Access토큰은 Async storage에 저장된다.

   두 토큰은 만료 기간이 다른데, Refresh token의 만료 기간은 길게, Access token의 만료기간은 짧게 설정한다. 이렇게 하는 이유는 앱내에서 시행되는 모든 요청은 Access token을 이용하게 되는데, 혹시 token이 누출되더라도 짧은 만료기간을 이용해 무력화 시키기 위함이다.

   Access token이 만료되면 Refresh token을 서버에 보내 Access token을 재발급 받는다.

3. 회원가입 이후에는, 사용자가 앱을 실행시키는 시점에서 항상 서버에게 Refresh token을 보내 Access token을 갱신한다. 이렇게 하는 이유는 사용자가 앱을 사용하는동안에 토큰이 만료됨을 방지하기 위함이다. Access token의 만료시간은 2시간으로 설정했다.

4. 사용자가 앱을 실행시켰을 때 Refresh token이 만료되었다면, 안전한 저장소에 저장해두었던 사용자 정보를 가져와 로그인 요청을 보낸다.( 이때는 사용자가 로그인을 하는게 아니라 자동으로 처리된다. )

5. 로그인 요청에 응답으로 Refresh token과 Access token이 사용자에게 오게된다. 이렇게 함으로써 사용자가 로그아웃을 하지 않는다면 로그인 상태를 유지된다.